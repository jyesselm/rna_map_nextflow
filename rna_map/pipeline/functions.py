"""Functional APIs for RNA MAP pipeline components.

These functions provide stateless, composable interfaces to pipeline components.
They can be used independently or in any order, unlike the class-based APIs.
"""

import os
from pathlib import Path
import pickle

from rna_map.analysis.mutation_histogram import MutationHistogram
from rna_map.core.config import BitVectorConfig
from rna_map.core.results import BitVectorResult
from rna_map.logger import get_logger
from rna_map.pipeline.bit_vector_generator import BitVectorGenerator

log = get_logger("PIPELINE.FUNCTIONS")


def generate_bit_vectors(
    sam_path: Path,
    fasta: Path,
    output_dir: Path,
    config: BitVectorConfig,
    csv_file: Path | None = None,
    paired: bool | None = None,
    use_stricter_constraints: bool = False,
) -> BitVectorResult:
    """Generate bit vectors from SAM file and return result.

    This is a functional, stateless API that can be used independently.
    This function is used by the Nextflow workflow to generate bit vectors from SAM files.

    Args:
        sam_path: Path to SAM file (can be from anywhere)
        fasta: Path to FASTA file
        output_dir: Output directory for bit vector files
        config: Bit vector configuration
        csv_file: Optional CSV file with structure info
        paired: Whether reads are paired-end (auto-detected if None)
        use_stricter_constraints: Whether to apply stricter constraints

    Returns:
        BitVectorResult with mutation histograms and output paths

    Example:
        >>> from rna_map.core.config import BitVectorConfig
        >>> config = BitVectorConfig(map_score_cutoff=20)
        >>> result = generate_bit_vectors(
        ...     sam_path=Path("aligned.sam"),
        ...     fasta=Path("ref.fa"),
        ...     output_dir=Path("output"),
        ...     config=config
        ... )
        >>> print(result.summary_path)
    """
    # Auto-detect paired-end if not specified
    if paired is None:
        # Simple heuristic: check if SAM has paired reads
        # This is a basic check - could be improved
        try:
            with open(sam_path) as f:
                first_line = f.readline()
                while first_line.startswith("@"):
                    first_line = f.readline()
                # Paired-end SAM files have flags indicating pairing
                if "\t" in first_line:
                    parts = first_line.split("\t")
                    if len(parts) > 1:
                        flag = int(parts[1]) if parts[1].isdigit() else 0
                        # Check if flag indicates paired (bit 0x1)
                        paired = (flag & 0x1) != 0
                    else:
                        paired = False
                else:
                    paired = False
        except Exception:
            # Fallback: assume single-end if detection fails
            paired = False

    # Build directory structure
    bv_dir = output_dir / "BitVector_Files"
    os.makedirs(output_dir, exist_ok=True)
    os.makedirs(bv_dir, exist_ok=True)

    # Create temporary params dict for BitVectorGenerator class
    params = {
        "dirs": {"output": str(output_dir)},
        "bit_vector": {
            "qscore_cutoff": config.qscore_cutoff,
            "num_of_surbases": config.num_of_surbases,
            "map_score_cutoff": config.map_score_cutoff,
            "plot_sequence": config.plot_sequence,
            "summary_output_only": config.summary_output_only,
            "storage_format": config.storage_format.value,
        },
        "restore_org_behavior": False,
        "stricter_bv_constraints": use_stricter_constraints,
    }

    if config.stricter_constraints:
        params["bit_vector"]["stricter_constraints"] = {
            "min_mut_distance": config.stricter_constraints.min_mut_distance,
            "percent_length_cutoff": config.stricter_constraints.percent_length_cutoff,
            "mutation_count_cutoff": config.stricter_constraints.mutation_count_cutoff,
        }

    # Use existing BitVectorGenerator class (maintains backward compatibility)
    generator = BitVectorGenerator()
    generator.setup(params)
    generator.run(
        sam_path=sam_path,
        fasta=fasta,
        paired=paired,
        csv_file=csv_file if csv_file else Path(""),
    )

    # Load mutation histograms from pickle file (generated by BitVectorGenerator)
    pickle_file = bv_dir / "mutation_histos.p"
    mut_histos: dict[str, MutationHistogram] = {}
    if pickle_file.exists():
        with open(pickle_file, "rb") as f:
            mut_histos = pickle.load(f)

    summary_path = bv_dir / "summary.csv"
    return BitVectorResult(
        mutation_histos=mut_histos,
        summary_path=summary_path,
        output_dir=bv_dir,
    )

